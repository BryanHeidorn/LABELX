#!perl
use strict;
use warnings;
use XML::LibXML
#use XML::LibXML::Common;
#use XML::LibXML::Common qw(:libxml);
#use XML::LibXML::Common qw(:encoding);
my $enc = 'utf-8'; # This script is stored as UTF-8
binmode(STDOUT, ":utf8");
use charnames ':full';

#############################################################################
# PERL Program "RelabelOtherinXML.pl"
#
# July 23, 2014-Nov 5, 2014
# Bryan Heidorn

# This program reads XML Directories of files. 
# A substitution table replaces <ot> tags with primarily tags to denote labels.
# This table may be generated by the program SelectOneElementFromXML. That program selects, sorts and counts content based on frequency. 

# Usage: SelectOneElementFromXML.pl XMLRootDirectory OutputFileName
# Process all files recursively in the directories
# 
$/ = "\r\n"
  ; # Change the builtin variable to require both an carrage return and line feed.
 # This allows multientry filed, fields with more than one valuse in a CSV to be seperated using just a bare \n""
my $numargs = @ARGV;

if ( $numargs ne "2" ) {
	print
"Usage:  $0  SelectOneElementFromXML.pl XMLRootDirectory OutputFileName\n";
	die;
}
my $XMLRootDirectory = $ARGV[0];
my $OutputRootFile   = $ARGV[1];

open( ERRORLOG, ">>ERRORCSV.log" )
	 || die "$! Could not Open ERRORCSV.log";

ConvertAllFiles($XMLRootDirectory);
close (ERRORLOG);
exit;

########################
sub ConvertAllFiles {
	my ($SubDirName) = @_;
	my $fn;
	my $FileWPath;
	my $line;
	my $derivedLine;
	my $selectedElement;
	my @matchList;
	local *DIRROOT;
	my %substitutionHash = (

'<ot>.No.</ot><recordNumber>' => 'recordNumberLabel', # 1
'<ot>275 WI</ot><datasetName>' => 'datasetNameLabel', # 1
'<ot>275</ot><datasetName>' => 'datasetNameLabel', # 1
'<ot>288 WI</ot><datasetName>' => 'datasetNameLabel', # 1
'<ot>288 WI</ot><verbatimInstitution>' => 'verbatimInstitutionLabel', # 1
'<ot>COLL:</ot><recordedBy>' => 'recordedByLabel', # 1
'<ot>COLLECTED BY</ot><recordedBy>' => 'recordedByLabel', # 1
'<ot>Collector:</ot><recordedBy>' => 'recordedByLabel', # 1
'<ot>Collectors</ot><verbatimEventDate>' => 'verbatimEventDateLabel', # 1
'<ot>DATE:</ot><verbatimEventDate>' => 'verbatimEventDateLabel', # 1
'<ot>DESCRIPTION:</ot><fieldNotes2>' => 'fieldNotes2Label', # 1
'<ot>Det.:</ot><identifiedBy>' => 'identifiedByLabel', # 1
'<ot>Familia Col.</ot><recordedBy>' => 'recordedByLabel', # 1
'<ot>Fecha:</ot><verbatimEventDate>' => 'verbatimEventDateLabel', # 1
'<ot>Fecha</ot><verbatimEventDate>' => 'verbatimEventDateLabel', # 1
'<ot>Gramineae</ot><scientificName>' => 'scientificNameLabel', # 1
'<ot>HABITAT:</ot><fieldNotes>' => 'fieldNotesLabel', # 1
'<ot>LOCALITY:</ot><verbatimLocality>' => 'verbatimLocalityLabel', # 1
'<ot>NEW YORK BOTANICAL GARDEN NEW YORK BOTANICAL GARDEN</ot><catalogNumber>' => 'catalogNumberLabel', # 1
'<ot>NEW YORK BOTANICAL GARDEN</ot><verbatimEventDate>' => 'verbatimEventDateLabel', # 1
'<ot>NO:</ot><recordNumber>' => 'recordNumberLabel', # 1
'<ot>NY IMAGED</ot><verbatimInstitution>' => 'verbatimInstitutionLabel', # 1
'<ot>No</ot><recordNumber>' => 'recordNumberLabel', # 1
'<ot>det</ot><identifiedBy>' => 'identifiedByLabel', # 1
'<ot>in</ot><stateProvince>' => 'stateProvinceLabel', # 1
'<ot>}COLLECTORS</ot><verbatimEventDate>' => 'verbatimEventDateLabel', # 1
#'<ot>(with</ot><recordedBy2>' => 'recordedBy2Label', # 2
'<ot>Collected for the</ot><verbatimInstitution>' => 'verbatimInstitutionLabel', # 2
'<ot>Date:</ot><verbatimEventDate>' => 'verbatimEventDateLabel', # 2
'<ot>Herbarium</ot><verbatimInstitution>' => 'verbatimInstitutionLabel', # 2
'<ot>with</ot><recordedBy2>' => 'recordedBy2Label', # 2
'<ot>det.</ot><identifiedBy>' => 'identifiedByLabel', # 3
'<ot>}COLLECTORS</ot><recordedBy3>' => 'recordedBy3Label', # 3
'<ot>COLL.</ot><recordedBy>' => 'recordedByLabel', # 4
'<ot>Collected by</ot><recordedBy>' => 'recordedByLabel', # 4
'<ot>Coll.</ot><recordedBy>' => 'recordedByLabel', # 5
'<ot>Determined by</ot><identifiedBy>' => 'identifiedByLabel', # 6
'<ot>NO.</ot><recordNumber>' => 'recordNumberLabel', # 10
'<ot>Det.</ot><identifiedBy>' => 'identifiedByLabel', # 12
'<ot>Det:</ot><identifiedBy>' => 'identifiedByLabel', # 17
'<ot>No.</ot><recordNumber>' => 'recordNumberLabel', # 23
'<ot>NEW YORK BOTANICAL GARDEN</ot><catalogNumber>' => 'catalogNumberLabel', # 69
'<ot>1 2 3 4 5 6 7 8 9 10 cm copyright reserved</ot><verbatimInstitution>' => 'verbatimInstitutionLabel' # 98


);
	#print "$SubDirName\n";
	opendir( DIRROOT, $SubDirName )
	  or die 'Cannot open directory ', *DIRROOT, ' ', $SubDirName, ": $!";
	my $xmlparser = XML::LibXML->new();
	  
	my $matchListIndex = 0;
	while ( my $fn = readdir DIRROOT ) {
		#$FileWPath = $SubDirName . '\\' . $fn;    #slash for Windows
		$FileWPath = $SubDirName . '/' . $fn;     #slash for Macs

		#print "This -d: ", $FileWPath, "\n" if -d $FileWPath;
		unless ( $fn =~ m/^\./ ) 
			{ # if it begins with a "." do nothing    #get rid of second slash for Macs
			if ( -d $FileWPath )
				{    # if it isa directory call the routine to open the DIRECTORY
					#print "is a directory: ", $FileWPath, "\n";
					ConvertAllFiles($FileWPath);
				}
			elsif ( $fn =~ /\.xml$/i ) {    # Only files ending in .xml
				                            # Open the file
				$/ = "\n";

				local *XMLFILESFILE;
   		 		#print "Open $FileWPath\n";
				my $FieldList = $xmlparser->parse_file($FileWPath);	
    			$FieldList->setEncoding('UTF-8');
				#unless ( open( XMLFILESFILE, "<:encoding(utf8)", $FileWPath ) ) {
				#	print "$0 Error: ", $FileWPath,
				#  	" XML file of file names cannot be opened.\n";
				#	die;				
				#}

				#get the file name to append to the output root directory name
				my $NewXMLFileName2;    #for XML output file
				$NewXMLFileName2 = substr( $FileWPath, length($XMLRootDirectory) );
				my $XMLFileName2;
				$XMLFileName2 = $OutputRootFile . $NewXMLFileName2;
				
				#print "This is the XMLFileName2: $XMLFileName2\n";
				open( OUTPUT, ">:encoding(UTF-8)", $XMLFileName2 )
				  || die "$! Could not Open $XMLFileName2";
				
				foreach my $element ($FieldList->findnodes('ot'))
				while ( $line = <XMLFILESFILE> ) {
					chomp $line;
					# print "$line\n";
					$selectedElement = $line;
					$derivedLine = $line;
					#print "$derivedLine\n";
					while ($selectedElement =~ /\<ot\>(.+?)\<\/ot\>(\<\w+?\>)/g) {
						$matchList[$matchListIndex++] = "$1$2";
						my $otherContent = $1;
						my $followingTag = $2;
						my $key = "<ot>$otherContent<\/ot>$followingTag";
						#print "Key=$key\n";
						if (exists $substitutionHash{$key}) {
							$derivedLine =~ s/$key/<$substitutionHash{$key}>$otherContent<\/$substitutionHash{$key}>$followingTag/g;
						}
					}
					print "$derivedLine\n";
					print OUTPUT $derivedLine;
					
					
				}
			}
		} # end unless
	} # end while
=begin comment
	open( OUTPUT, ">$OutputRootFile" ) || die "$! Could not Open $OutputRootFile";
	foreach (sort { ($dups{$a} <=> $dups{$b}) || ($a cmp $b) } keys %dups) 
	{
	    print "$dups{$_}: $_\n";
	    print OUTPUT "$dups{$_}: $_\n";
	    
	}
	close(OUTPUT);
=end comment
=cut							
}
